---
layout: main
overview: true
sections: {
  short-bio: "Short Bio",
  papers: "Papers",
  software: "Software",
  service: "Service",
  personal: "Personal"
}
---

<h2 class="page-heading">Overview</h2>

<p class="homepage">
    I am a PhD student at the University of Pennsylvania, where I am
    fortunate to be advised
    by <a href="https://www.cis.upenn.edu/~alur/">Rajeev Alur</a>. My
    research interests lie in the intersection of programming
    languages, distributed systems, and software verification. I am
    particularly interested in ways of making distributed systems
    development more reliable and secure.
</p>

<ul class="contents">
  {% for section in page.sections %}
    <li><a href="#{{ section[0] }}">{{ section[1] }}</a></li>
  {% endfor %}
</ul>

<hr>

<!-- <h2 class="page-heading">Current Research</h2> -->

<!-- <\!-- TODO: Add links, and bod, emphasis. Also add a link to the section. -\-> -->

<!-- <p class="homepage"> -->
<!-- I am currently working on <em>distributed stream processing</em>. More -->
<!-- precisely, I am interested in improving the support for specification -->
<!-- and implementation of correct distributed stream processing -->
<!-- applications, either by designing expressive programming models that -->
<!-- offer correctness by construction, or by developing tools for checking -->
<!-- correctness of existing applications. A necessary prerequisite to -->
<!-- achieve these goals is to rethink the conceptual foundation of -->
<!-- distributed stream processing. -->
<!-- </p> -->

<!-- <p class="homepage"> -->
<!-- In recent years, distributed stream processing frameworks (such as -->
<!-- Flink, Spark-Streaming, Storm, and Twitter Heron) have seen a massive -->
<!-- popularity increase, an increase that can mostly be attributed to the -->
<!-- surge in the amount of data that needs to be processed in real-time -->
<!-- with minimal latency. These systems offer enticing performance -->
<!-- benefits (mostly in latency and throughput) by using aggressive -->
<!-- parallelization techniques to leverage the available distributed -->
<!-- computation resources. -->
<!-- </p> -->

<!-- <p class="homepage"> -->
<!-- However, these performance benefits don't always come without a cost, -->
<!-- impeding development of applications in these frameworks in two -->
<!-- ways. First, their programming interfaces are limited to a restricted -->
<!-- class of streaming computations. Computations that do not fall in this -->
<!-- class can only be implemented with low level primitives, circumventing -->
<!-- the programming model of the framework. Second, checking correctness -->
<!-- of applications in these frameworks is extremely error-prone, as there -->
<!-- are implicit assumptions---often documented just in text---that the -->
<!-- user-written code has to satisfy in order for the computation to be -->
<!-- correct. -->
<!-- <\!-- This motivates the development of both (i) more -\-> -->
<!-- <\!-- expressive programming frameworks that can implement a wider class of -\-> -->
<!-- <\!-- computations in a distributed way, as well as (ii) tools that offer -\-> -->
<!-- <\!-- support for checking the correctness of distributed streaming -\-> -->
<!-- <\!-- applications written by users. -\-> -->
<!-- </p> -->

<!-- <p class="homepage"> -->
<!-- To address the expressiveness issue, we have -->
<!-- developed <a href="https://github.com/angelhof/flumina">Flumina</a>, a -->
<!-- programming framework and system that can support and implement -->
<!-- computations that involve state and therefore cannot be distributed -->
<!-- straightforwardly. These computations cannot be expressed by the -->
<!-- dataflow graph model or the SQL-like languages that modern systems -->
<!-- support, so the user has to resort to manual synchronization to -->
<!-- implement these computations in a distributed way. Our programming -->
<!-- model supports these computations by viewing input streams as partial -->
<!-- orders instead of sequences of events. Events that are unordered, can -->
<!-- be safely processed independently in a distributed fashion, and -->
<!-- synchronization only happens when order is necessary. The programming -->
<!-- model requires that the user writes a sequential specification and -->
<!-- some distribution primitives, and the underlying system generates a -->
<!-- correct distributed implementation. With the Flumina programming model -->
<!-- as a compilation target, our goal is to develop a high-level query -->
<!-- language on top if it that can support a wider class of computations -->
<!-- than all current frameworks do. -->
<!-- </p> -->

<!-- <p class="homepage"> -->
<!-- To address the correctness issue, we are working on tools for testing -->
<!-- the correctness of applications written in existing distributed stream -->
<!-- processing frameworks. In order to do that, a fundamental challenge is -->
<!-- to define what it means for a distributed streaming computation to be -->
<!-- correct. We defined correctness of such computations with respect to a -->
<!-- sequential one, and we developed a testing algorithm that checks two -->
<!-- streaming computations for equivalence. We are currently in the -->
<!-- process of packaging the tool to release it for public use for Apache -->
<!-- Flink programs. -->
<!-- </p> -->

<!-- <p class="homepage"> -->
<!-- There are a lot of programming frameworks for the implementation of -->
<!-- distributed stream processing systems, and all of them offer great -->
<!-- performance. But is is almost always uncertain, whether the resulting -->
<!-- application satisfies the intention that the developers had in mind. -->

<!-- Obviously the first step towards this direction is defining reasonably -->
<!-- loose notions of correctness. When implementing distributed -->
<!-- applications, it is clear that some properties are lost for (better -->
<!-- word for 'for') performance, fault-tolerance (and all the other benefits of -->
<!-- distributed implementations. -->

<!-- It is very important to know what one loses when using these -->
<!-- frameworks, and only make these tradeoffs when possible. -->

<!-- One of this looseness/tradeoff criteria that we have found is -->
<!-- ordering. More concretely, for which input items the result of the -->
<!-- implementation is causally dependent. Some input items can be -->
<!-- reordered without any impact to the result of the computation, while -->
<!-- if others are reordered, the result of the computation is different -->
<!-- and/or wrong. -->

<!-- We have captured this notion of need for order of events with a notion -->
<!-- called dependency relation. A user can then sepcify the dependency -->
<!-- relation for their application, and the underlying system should -->
<!-- ensure that dependent events will never be reordered. With my -->
<!-- collaborators we have implemented a programming framework based on -->
<!-- this model, and a system that implements it. -->

<!-- Note that the need for order is just one of the many requirements that -->
<!-- an application might have on its inputs, so a major goal of this -->
<!-- research is to define what type of requirements does a stream -->
<!-- processing application can have from its environment, and what -->
<!-- requirements does its environment have on it, so that we can ensure -->
<!-- that underlying systems are able to achieve performance and other -->
<!-- benefits without violating a requirement that the environment might -->
<!-- have. -->
<!-- </p> -->

<h2 id="short-bio" class="page-heading">{{ page.sections.short-bio }}</h2>

<p class="homepage">
  I spent the summer of 2019 in
  the <a href="https://aws.amazon.com/security/provable-security/">Automated
  Reasoning Group</a> at Amazon Web Services under the supervision
  of <a href="https://www.linkedin.com/in/daniel-schwartz-narbonne-5036b9137/">Daniel
  Schwartz-Narbonne</a>. We used the C Bounded Model Checker
  (<a href="http://www.cprover.org/cbmc/">CBMC</a>) to verify that
  certain critical C libraries
  (<a href="https://github.com/awslabs/aws-c-common">aws-c-common</a>, <a href="https://github.com/aws/aws-encryption-sdk-c">aws-esdk-c</a>)
  are memory safe and satisfy important functional correctness
  properties. In the process, I implemented several small extensions
  for CBMC, mostly focused on improving the support for function
  contracts.
</p>

<p class="homepage">
  Before my PhD, I was an undergraduate student at
  the <a href="https://www.ntua.gr/en/">National Technical University
  of Athens</a>, department
  of <a href="https://www.ece.ntua.gr/en">Electrical and Computer
  Engineering</a>. I completed my thesis “HiPErJiT: A Profile-Driven
  Just-in-Time Compiler for Erlang based on HiPE” under the
  supervision of <a href="http://user.it.uu.se/~kostis/">Kostis
  Sagonas</a>. It is available online in
  both <a href="/files/theses-reports/thesis.pdf">English</a>
  and <a href="/files/theses-reports/thesis_gr.pdf">Greek</a>.
</p>

<p class="homepage">
  In May of 2018 I participated in
  the <a href="http://fm.csl.sri.com/SSFT18/">Eighth Summer School on
  Formal Techniques</a> that took place in Atherton, California and
  was organized by <a href="https://www.sri.com/">SRI
  International</a>.
</p>

<p class="homepage">
  Throughout my undergraduate studies I have developed software for
  many projects with my colleagues. Some notable examples are a
  complete compiler for the language Edsger
  (<a href="https://github.com/angelhof/edsger_compiler">source</a>),
  an implementation of the Chord protocol
  (<a href="https://github.com/angelhof/chord-distributed-erlang">source</a>),
  and an extension of the SIP Communicator
  (<a href="https://github.com/angelhof/sip-project-extensions">source</a>).
</p>

<p class="homepage">
  I have also participated in Google Summer of Code 2017, where I
  worked with <a href="https://github.com/zinid">Evgeny Khramtsov</a>
  to
  extend <a href="https://github.com/processone/ejabberd">ejabberd</a>. I
  implemented a mechanism that allows for certificate acquiring
  through the <a href="https://github.com/ietf-wg-acme/acme">ACME</a>
  protocol.
</p>

<hr>

{% include_relative pubs.html %}

<hr>

<h2 id="software" class="page-heading">{{ page.sections.software }}</h2>

<ul>
  <li>
    <b>Flumina</b> (<a href="https://github.com/angelhof/flumina">GitHub</a>) <br>
    A programming model and system for stateful distributed streaming computations.
  </li>
  <li>
    <b>DiffStream</b> (<a href="https://github.com/fniksic/diffstream">GitHub</a>) <br>
    A differential testing library for stream processing applications in Apache Flink.
  </li>
</ul>

<hr>

<h2 id="service" class="page-heading">{{ page.sections.service }}</h2>

<ul>
  <li><b>POPL 2020</b> External Reviewer</li>
</ul>

<hr>

<h2 id="personal" class="page-heading">{{ page.sections.personal }}</h2>

<p class="homepage">
  In my free time I enjoy programming (for fun or in programming
  competitions), board games, <a href="/escape_rooms.html"
  rel="nofollow" style="color: inherit">escape rooms</a>, and ping
  pong. I also occasionally play guitar in an amateur jam band.
</p>
