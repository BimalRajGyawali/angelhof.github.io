---
layout: main
overview: true
sections: {
  research: "Research",
  short-bio: "Short Bio",
  papers: "Papers",
  awards: "Awards",
  software: "Software",
  service: "Service",
  personal: "Personal"
}
---

<h2 class="page-heading">Overview</h2>

<p class="homepage">
    I am a PhD student at the University of Pennsylvania, where I am
    fortunate to be advised
    by <a href="https://www.cis.upenn.edu/~alur/">Rajeev Alur</a>. My
    research interests lie in the intersection of programming
    languages, distributed systems, and software verification.    
</p>

<p class="homepage">
  <b>Quick Links:</b>
  <a href="#research">{{ page.sections.research }}</a>, 
  <a href="#short-bio">{{ page.sections.short-bio }}</a>, 
  <a href="#papers">{{ page.sections.papers }}</a>, 
  <a href="#awards">{{ page.sections.awards }}</a>, 
  <a href="#software">{{ page.sections.software }}</a>, 
  <a href="#service">{{ page.sections.service }}</a>,
  <a href="#personal">{{ page.sections.personal }}</a>
</p>

<!-- <ul class="contents">
  {% for section in page.sections %}
    <li><a href="#{{ section[0] }}">{{ section[1] }}</a></li>
  {% endfor %}
</ul> -->

<hr>

<h2 id="research" class="page-heading">{{ page.sections.research }}</h2>

<h3 class="page-heading">Automatic parallelization of shell scripts</h3>

<p class="homepage">
  <b>Links:</b> 
  <a class="name-link" href="https://github.com/andromeda/pash">PaSh</a>
  <a class="github-button" href="https://github.com/andromeda/pash" data-icon="octicon-star"  data-show-count="true" aria-label="Star andromeda/pash on GitHub">Star</a>,
  <!-- Place this tag where you want the button to render. -->
  <a class="name-link" href="https://arxiv.org/abs/2007.09436">PaSh paper (EuroSys 2021)</a>,
  <a class="name-link" href="https://arxiv.org/abs/2012.15422">Dataflow paper (In submission)</a>,
  <a class="name-link" href="https://www.youtube.com/watch?v=3uqYJo1v1E0">Short video (POPL SRC)</a>
</p>

<!-- <p class="homepage">
  <a class="github-button" href="https://github.com/andromeda/pash" data-icon="octicon-star"  data-show-count="true" aria-label="Star andromeda/pash on GitHub">Star</a>  
</p> -->

<p class="homepage">
  <b>Collaborators:</b>
  <a class="name-link" href="http://nikos.vasilak.is/">Nikos Vasilakis</a>,
  <a class="name-link" href="https://www.linkedin.com/in/achilles-benetopoulos/">Achilleas Benetopoulos</a>,
  <a class="name-link" href="https://github.com/cvetkovic">Lazar M. Cvetković</a>,
  <a class="name-link" href="https://dblp.org/pid/220/9099.html">Shivam Handa</a>,
  <a class="name-link" href="https://mamouras.web.rice.edu/">Konstantinos Mamouras</a>,
  and <a class="name-link" href="https://people.csail.mit.edu/rinard/">Martin Rinard</a>
</p>

<p class="homepage">
  Together with <a href="http://nikos.vasilak.is/">Nikos Vasilakis</a>, we are 
  leading a research project on the automatic parallelization of shell scripts.
  The ultimate goal is to improve our understanding of the shell, 
  approaching it from a programming languages viewpoint, and build frameworks
  that enable further studies and analyses on it.

  Our first paper on this work was published at EuroSys 2021 
  (<a href="https://arxiv.org/abs/2007.09436">preprint</a>).
  One of the main challenges that we had to overcome is that shell commands
  are arbitrary black boxes that can be written in a plethora of programming languages,
  making any analysis infeasible.
  We addressed that by developing an annotation language that captures a few key properties
  of shell commands that can then be used by our system to parallelize a script.
  These annotations are written once per command, and can be shared among users
  in the form of annotation libraries.
  
  We are also working on a paper 
  (<a href="https://arxiv.org/abs/2012.15422">preprint</a>) 
  that formalizes an order-aware dataflow model that is equivalent to a "scheduling-free" fragment of the shell.
  We use this model as an convenient representation on which we apply transformations that expose parallelism.
  After we are done parallelizing, the dataflow graph is transformed back to a shell script that can
  execute on any standard shell.

  Our work is open-source and available on <a href="https://github.com/andromeda/pash">Github</a>.
</p>

<h3 class="page-heading">Partial order driven stream processing</h3>

<p class="homepage">
  <b>Links:</b> 
  <a class="name-link" href="https://github.com/angelhof/flumina">Flumina on Github</a>
  <a class="github-button" href="https://github.com/angelhof/flumina" data-icon="octicon-star"  data-show-count="true" aria-label="Star angelhof/flumina on GitHub">Star</a>,
  <a class="name-link" href="https://github.com/fniksic/diffstream">Diffstream on GitHub</a>
  <a class="github-button" href="https://github.com/fniksic/diffstream" data-icon="octicon-star"  data-show-count="true" aria-label="Star fniksic/diffstream on GitHub">Star</a>,
  <a class="name-link" href="https://dl-acm-org.proxy.library.upenn.edu/doi/abs/10.1145/3428221">Diffstream paper (OOPSLA 2020)</a>
</p>

<p class="homepage">
  <b>Collaborators:</b>
  <a class="name-link" href="https://www.cis.upenn.edu/~alur/">Rajeev Alur</a>,
  <a class="name-link" href="https://fniksic.github.io/">Filip Niksic</a>,
  and <a class="name-link" href="https://www.cis.upenn.edu/~castan/">Caleb Stanford</a>
  
</p>

<p class="homepage">
  Existing abstractions for stream processing either consider streams to either be totally ordered sequences,
  completely unordered relations, or some fixed point in between, e.g., CQL considers streams to be sequences of relations.

  However, these representations face a number of issues.
  If a representation does not capture adequate order, streaming queries can produce erroneous results
  due to nondeterminism and out-of-order input data.
  If a representation is "too ordered", then it does not expose available parallelism,
  and optimizations due to lack of order.
  We propose a flexible partial order abstraction that can capture fine-grained ordering requirements,
  allowing for correct and maximally parallel stream processing.

  Our first paper on this work was published at OOPSLA 2020
  (<a href="https://dl-acm-org.proxy.library.upenn.edu/doi/abs/10.1145/3428221">link</a>),
  where we describe a differential testing framework 
  (<a href="https://github.com/fniksic/diffstream">code</a>)
  for stream processing applications that allows
  users to define the ordering requirements on their application's output, improving testing accuracy.

  We are also working on a programming model that can exploit the partially ordered nature of the input stream,
  generating highly parallel implementations. This work is under submission, 
  but a prototype of the code is available on 
  (<a href="https://github.com/angelhof/flumina">Github</a>).
</p>

<hr>

<!-- <h2 class="page-heading">Current Research</h2> -->

<!-- <\!-- TODO: Add links, and bod, emphasis. Also add a link to the section. -\-> -->

<!-- <p class="homepage"> -->
<!-- I am currently working on <em>distributed stream processing</em>. More -->
<!-- precisely, I am interested in improving the support for specification -->
<!-- and implementation of correct distributed stream processing -->
<!-- applications, either by designing expressive programming models that -->
<!-- offer correctness by construction, or by developing tools for checking -->
<!-- correctness of existing applications. A necessary prerequisite to -->
<!-- achieve these goals is to rethink the conceptual foundation of -->
<!-- distributed stream processing. -->
<!-- </p> -->

<!-- <p class="homepage"> -->
<!-- In recent years, distributed stream processing frameworks (such as -->
<!-- Flink, Spark-Streaming, Storm, and Twitter Heron) have seen a massive -->
<!-- popularity increase, an increase that can mostly be attributed to the -->
<!-- surge in the amount of data that needs to be processed in real-time -->
<!-- with minimal latency. These systems offer enticing performance -->
<!-- benefits (mostly in latency and throughput) by using aggressive -->
<!-- parallelization techniques to leverage the available distributed -->
<!-- computation resources. -->
<!-- </p> -->

<!-- <p class="homepage"> -->
<!-- However, these performance benefits don't always come without a cost, -->
<!-- impeding development of applications in these frameworks in two -->
<!-- ways. First, their programming interfaces are limited to a restricted -->
<!-- class of streaming computations. Computations that do not fall in this -->
<!-- class can only be implemented with low level primitives, circumventing -->
<!-- the programming model of the framework. Second, checking correctness -->
<!-- of applications in these frameworks is extremely error-prone, as there -->
<!-- are implicit assumptions---often documented just in text---that the -->
<!-- user-written code has to satisfy in order for the computation to be -->
<!-- correct. -->
<!-- <\!-- This motivates the development of both (i) more -\-> -->
<!-- <\!-- expressive programming frameworks that can implement a wider class of -\-> -->
<!-- <\!-- computations in a distributed way, as well as (ii) tools that offer -\-> -->
<!-- <\!-- support for checking the correctness of distributed streaming -\-> -->
<!-- <\!-- applications written by users. -\-> -->
<!-- </p> -->

<!-- <p class="homepage"> -->
<!-- To address the expressiveness issue, we have -->
<!-- developed <a href="https://github.com/angelhof/flumina">Flumina</a>, a -->
<!-- programming framework and system that can support and implement -->
<!-- computations that involve state and therefore cannot be distributed -->
<!-- straightforwardly. These computations cannot be expressed by the -->
<!-- dataflow graph model or the SQL-like languages that modern systems -->
<!-- support, so the user has to resort to manual synchronization to -->
<!-- implement these computations in a distributed way. Our programming -->
<!-- model supports these computations by viewing input streams as partial -->
<!-- orders instead of sequences of events. Events that are unordered, can -->
<!-- be safely processed independently in a distributed fashion, and -->
<!-- synchronization only happens when order is necessary. The programming -->
<!-- model requires that the user writes a sequential specification and -->
<!-- some distribution primitives, and the underlying system generates a -->
<!-- correct distributed implementation. With the Flumina programming model -->
<!-- as a compilation target, our goal is to develop a high-level query -->
<!-- language on top if it that can support a wider class of computations -->
<!-- than all current frameworks do. -->
<!-- </p> -->

<!-- <p class="homepage"> -->
<!-- To address the correctness issue, we are working on tools for testing -->
<!-- the correctness of applications written in existing distributed stream -->
<!-- processing frameworks. In order to do that, a fundamental challenge is -->
<!-- to define what it means for a distributed streaming computation to be -->
<!-- correct. We defined correctness of such computations with respect to a -->
<!-- sequential one, and we developed a testing algorithm that checks two -->
<!-- streaming computations for equivalence. We are currently in the -->
<!-- process of packaging the tool to release it for public use for Apache -->
<!-- Flink programs. -->
<!-- </p> -->

<!-- <p class="homepage"> -->
<!-- There are a lot of programming frameworks for the implementation of -->
<!-- distributed stream processing systems, and all of them offer great -->
<!-- performance. But is is almost always uncertain, whether the resulting -->
<!-- application satisfies the intention that the developers had in mind. -->

<!-- Obviously the first step towards this direction is defining reasonably -->
<!-- loose notions of correctness. When implementing distributed -->
<!-- applications, it is clear that some properties are lost for (better -->
<!-- word for 'for') performance, fault-tolerance (and all the other benefits of -->
<!-- distributed implementations. -->

<!-- It is very important to know what one loses when using these -->
<!-- frameworks, and only make these tradeoffs when possible. -->

<!-- One of this looseness/tradeoff criteria that we have found is -->
<!-- ordering. More concretely, for which input items the result of the -->
<!-- implementation is causally dependent. Some input items can be -->
<!-- reordered without any impact to the result of the computation, while -->
<!-- if others are reordered, the result of the computation is different -->
<!-- and/or wrong. -->

<!-- We have captured this notion of need for order of events with a notion -->
<!-- called dependency relation. A user can then sepcify the dependency -->
<!-- relation for their application, and the underlying system should -->
<!-- ensure that dependent events will never be reordered. With my -->
<!-- collaborators we have implemented a programming framework based on -->
<!-- this model, and a system that implements it. -->

<!-- Note that the need for order is just one of the many requirements that -->
<!-- an application might have on its inputs, so a major goal of this -->
<!-- research is to define what type of requirements does a stream -->
<!-- processing application can have from its environment, and what -->
<!-- requirements does its environment have on it, so that we can ensure -->
<!-- that underlying systems are able to achieve performance and other -->
<!-- benefits without violating a requirement that the environment might -->
<!-- have. -->
<!-- </p> -->

<h2 id="short-bio" class="page-heading">{{ page.sections.short-bio }}</h2>

<!-- Add a paragraph about PaSh (either here, or above as current research). -->

<p class="homepage">
  During the unconventional summer of 2020 I did an internship
  in <a href="https://www.microsoft.com/en-us/research/group/research-software-engineering-rise/">RiSE</a>
  in Microsoft Research where I worked
  with <a href="https://www.microsoft.com/en-us/research/people/sburckha/">Sebastian
  Burckhardt</a>. During my internship we worked on a new
  implementation
  of <a href="https://docs.microsoft.com/en-us/azure/azure-functions/durable/durable-functions-versions">Azure
  Durable Functions</a>, a programming model for reliable stateful
  serverless applications. The new implementation,
  called <em>Netherite</em>, guarantees reliable execution of stateful
  applications and achieves an order of magnitude improvements in
  throughput and latency compared to the existing
  implementation. These performance improvements can be attributed to
  a series of optimizations, such as batching and speculation, that
  both reduce the number of storage accesses as well move them out of
  the critical path.
</p>

<p class="homepage">
  I spent the summer of 2019 in
  the <a href="https://aws.amazon.com/security/provable-security/">Automated
  Reasoning Group</a> at Amazon Web Services under the supervision
  of <a href="https://www.linkedin.com/in/daniel-schwartz-narbonne-5036b9137/">Daniel
  Schwartz-Narbonne</a>. We used the C Bounded Model Checker
  (<a href="http://www.cprover.org/cbmc/">CBMC</a>) to verify that
  certain critical C libraries
  (<a href="https://github.com/awslabs/aws-c-common">aws-c-common</a>, <a href="https://github.com/aws/aws-encryption-sdk-c">aws-esdk-c</a>)
  are memory safe and satisfy important functional correctness
  properties. In the process, I implemented several small extensions
  for CBMC, mostly focused on improving the support for function
  contracts.
</p>

<p class="homepage">
  Before my PhD, I was an undergraduate student at
  the <a href="https://www.ntua.gr/en/">National Technical University
  of Athens</a>, department
  of <a href="https://www.ece.ntua.gr/en">Electrical and Computer
  Engineering</a>. I completed my thesis “HiPErJiT: A Profile-Driven
  Just-in-Time Compiler for Erlang based on HiPE” under the
  supervision of <a href="http://user.it.uu.se/~kostis/">Kostis
  Sagonas</a>. It is available online in
  both <a href="/files/theses-reports/thesis.pdf">English</a>
  and <a href="/files/theses-reports/thesis_gr.pdf">Greek</a>.
</p>

<p class="homepage">
  In May of 2018 I participated in
  the <a href="http://fm.csl.sri.com/SSFT18/">Eighth Summer School on
  Formal Techniques</a> that took place in Atherton, California and
  was organized by <a href="https://www.sri.com/">SRI
  International</a>.
</p>

<p class="homepage">
  Throughout my undergraduate studies I have developed software for
  many projects with my colleagues. Some notable examples are a
  complete compiler for the language Edsger
  (<a href="https://github.com/angelhof/edsger_compiler">source</a>),
  an implementation of the Chord protocol
  (<a href="https://github.com/angelhof/chord-distributed-erlang">source</a>),
  and an extension of the SIP Communicator
  (<a href="https://github.com/angelhof/sip-project-extensions">source</a>).
</p>

<p class="homepage">
  I have also participated in Google Summer of Code 2017, where I
  worked with <a href="https://github.com/zinid">Evgeny Khramtsov</a>
  to
  extend <a href="https://github.com/processone/ejabberd">ejabberd</a>. I
  implemented a mechanism that allows for certificate acquiring
  through the <a href="https://github.com/ietf-wg-acme/acme">ACME</a>
  protocol.
</p>

<hr>

{% include_relative pubs.html %}

<hr>

<h2 id="awards" class="page-heading">{{ page.sections.awards }}</h2>

<ul>
  <li><b>POPL 2021 Student Research Competition</b> 1st place at Graduate Category</li>
  <li><b>Gerondelis Foundation PhD Award</b></li>
</ul>


<hr>

<h2 id="software" class="page-heading">{{ page.sections.software }}</h2>

<ul>
  <li>
    <b>PaSh</b> (<a href="https://github.com/andromeda/pash">GitHub</a>) 
    <a class="github-button" href="https://github.com/andromeda/pash" data-icon="octicon-star"  data-show-count="true" aria-label="Star andromeda/pash on GitHub">Star</a>
    <br>
    A system that automatically parallelizes <em>your</em> shell scripts.
  </li>
  <li>
    <b>Flumina</b> (<a href="https://github.com/angelhof/flumina">GitHub</a>)
    <a class="github-button" href="https://github.com/angelhof/flumina" data-icon="octicon-star"  data-show-count="true" aria-label="Star angelhof/flumina on GitHub">Star</a>
    <br>
    A programming model and system for stateful distributed streaming computations.
  </li>
  <li>
    <b>DiffStream</b> (<a href="https://github.com/fniksic/diffstream">GitHub</a>)
    <a class="github-button" href="https://github.com/fniksic/diffstream" data-icon="octicon-star"  data-show-count="true" aria-label="Star fniksic/diffstream on GitHub">Star</a>
    <br>
    A differential testing library for stream processing applications in Apache Flink.
  </li>
</ul>

<hr>

<h2 id="service" class="page-heading">{{ page.sections.service }}</h2>

<ul>
  <li><b>POPL 2022</b> Student Volunteer Co-Chair</li>
  <li><b>VMCAI 2021</b> Artifact Evaluation Committee</li>
  <li><b>POPL 2020</b> External Reviewer</li>
</ul>

<hr>

<h2 id="personal" class="page-heading">{{ page.sections.personal }}</h2>

<p class="homepage">
  In my free time I enjoy programming (for fun or in programming
  competitions), board games, <a href="/escape_rooms.html"
  rel="nofollow" style="color: inherit">escape rooms</a>, and ping
  pong. I also occasionally play guitar in an amateur jam band.
</p>
